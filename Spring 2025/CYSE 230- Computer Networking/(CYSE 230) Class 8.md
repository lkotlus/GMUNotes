### Midterm Results
- Max was a 97, average was a ~65, I got an 86.5, so not terrible.
- There is a curve, but I don't know what exactly my grade was curved to.
	- My midterm grade on patriotweb is an A+, so I should be fine. There is no specification, however, as to if this is a reference to the exam or to everything all together.
- I'll ask about specifics after class.
- The DNS question:
	- The message is referring to the authoritative DNS server.
	- I got this right!
- What gets sent and when:
	- Time 1 doesn't do anything, time 2 sends packet 2, time 3 doesn't do anything. The sender window doesn't move at any of the times.
	- I got this one right!
- rdt 2.2:
	- I recall most of the options being invalid...
	- I got this one right! Only one of them were valid!
- It seems like all together I did alright. Realistically I got some points off of one and got one completely wrong, for a total of -13.5.

### Network Layer
- Alright, so recall the network core (mainly routers). We have two core functions in routers:
	- Forward (local): send from input link to output link (like taking a single turn in the car)
	- Route (global): figure out the route that the packet will take (like planning a whole road trip)
- Our goals:
	- Understand principles behind network layer services, focusing on data plane:
		- Network layer service models
		- Forwarding versus routing
		- How a router works
		- Addressing
		- Generalized forwarding
		- Internet architecture
	- Instantiation and implementation on the internet:
		- Internet Protocol (IP)
		- NAT and middleboxes
- We will be starting off with the data plane and the control plane.
- Services and Protocols
	- We have a best-effort service model in the network layer. No guarantees on data transmission.
	- Transport segment from sending to receiving host:
		- Sending side encapsulates segments into datagrams and passes to the link layer.
		- Receiving side delivers segments to the transport layer
	- Network layer protocols are in ***every internet device***. Both hosts and routers. 
- The two key network-layer functions:
	- Forwarding:
		- Move packets from a router's input link to an appropriate router output link
	- Routing:
		- Determine route taken by packets from current place to destination
		- Intense routing algorithms (Dijkstra for real)
- Network and control planes:
	- Data plane:
		- Local, per-router function
		- Determines how a datagram arriving on a router input port is forwarded to a router output port
	- Control plane:
		- Network-wide logic
		- Determines how a datagram is routed among routers along the end to end path from source to destination
		- The individual routing algorithm components in all routers interact in the control plane.
		- Forwarding table:
			- Generated by the routing algorithm in the control plane, stored in teh data plane.
			- Determines where to forward data based on the value of a packet's header.
		- Software Defined Network (SDN) control plane:
			- For this we have a remote controller above the control plane to worry about.
- Service model:
	- Internet Network Architecture:
		- Best-effort:
			- We don't guarantee anything regarding bandwidth, loss, order, or timing. That's for the cucks developing TCP.
			- This ultimately makes sense, we don't want to bottleneck everything.
		- Intserv Guaranteed:
			- Bandwidth, loss, order, and timing guarantees.
		- Diffserv:
			- Possible bandwidth, loss, and order guarantees. No timing guarantees.
	- ATM Network Architecture:
		- Constant Bit Rate:
			- Constant bandwidth guarantee along with guarantees available for loss, order, and timing
		- Available Bit Rate:
			- Guaranteed minimum bandwidth, no loss guarantees, along with order and timing guarantees
	- Best effort services:
		- Simplicity of mechanism has allowed Internet to be widely deployed for Network Architecture.
- What's inside a router:
	- Overview:
		- The high level idea is just input ports and output ports.
		- Packets go through the physical, link, and network layer coming in. They go through the network, link, and physical going out.
		- We have high-speed switching fabric connecting input ports to output ports.
		- A routing processor controls the switching fabric.
		- Routing and management of the control plane is managed by the processor as well (software).
		- Forwarding and the data plane is mostly hardware.
	- Input ports:
		- Three functions (sort of like steps):
			1. Line termination (physical layer, bit reception)
			2. Link layer receive protocol (such as Ethernet)
			3. Lookup, forwarding, and queuing (network layer, decentralized switching using header field values)
				- Goal is complete input port processing at "line speed"
				- Input port queuing: if datagrams arrive faster than forwarding rate into switch fabric. We will drop packets if they surpass the queue size.
		- After these, datagrams go into the switch fabric.
- Destination Based Forwarding
	- Destination address range determines the link interface.
	- This is alright, but sometimes the ranges don't divide nicely.
	- So sometimes we have 11 bit ranges for two, an 8 bit range for one, and then just an else statement. This can result in collisions if we don't design it carefully.
	- Longest prefix matching means that we pick the case that matches the longest prefix (how many bits match before we reach wildcards). So for something like "oh, I match 110010000001011100011000\*\*\*\*\*\*\*\* and 110010000001011100011\*\*\*\*\*\*\*\*\*\*\*", you take the former because it's a longer prefix.
- Switching fabrics:
	- So we have $N$ input ports and $N$ output ports, and they are connected by high-speed switching fabric.
	- Switching fabric transfers packets from input links to output links
	- Switching rate: rate at which packets can be transferred from inputs to outputs
	- Three major types of fabrics:
		- Memory
			- Everything goes into memory, and then from memory to output
		- Bus
			- Direct input to output, no intermediate step
		- Interconnection network
			- We have a grid made up of "crossbars". It's super fast because our datagrams can take multiple routes to get sent to output simultaneously. 
			- Essentially making a switch fabric out of a bunch of smaller switches.
- Input port queuing:
	- If switch fabric is slower than input ports combined, queuing may occur at input queues. Queuing delay and loss is due to input buffer overflows.
	- Head-of-the-Line (HOL) blocking: queued datagram at front of queue prevents others in queue from moving forward.
- Output port queuing:
	- Buffering is required when datagrams arrive from fabric faster than link transmission rate.
	- Drop policy: which datagrams do we drop of there's no free buffers?
		- Drop from both congestion and lack of buffers
	- ISP determines the priority of a packet. Higher priority packets are kept, lower are dropped. 
	- Scheduling discipline:
		- Chooses among queued datagrams for transmission
- Buffering:
	- We have calculations to determine buffer sizes.
	- Larger isn't always better, transmission rates and congestion can really effect things!
	- Too much buffering creates delays, especially in home routers.
- Packet scheduling:
	- Priority
		- Arriving traffic classified and queued by class
		- Any header fields can be used for classification
		- Send packets from highest priority queue that has buffered packets, and use FCFS within priority class
	- FCFS (First Come First Serve)
		- Duh, just based on arrival time at the router
	- Round Robin (RR)
		- Arriving traffic classified and queued by class
		- Any header fields can be used for classification (just like priority)
		- Iterate through each class, sending one by one. If we have four classes (0, 1, 2, and 3), then we send from class in the order: 0, 1, 2, 3, 0, 1, 2, 3, 0, ...
		- Makes sense.
	- Weighted Fair Queuing (WFQ)
		- Generalized RR algorithm
		- Each class, $i$, ... she cut this off.
- Sidebar on network neutrality
	- What is network neutrality?
		- Essentially, can anyone use the network? Can we regulate use?
	- Can we allow ISPs to block people?
	- How fair is the internet for things like this? That's the whole thing.
	- There's just some real world examples on this in the slides, basic stuff.
- IP (Internet Protocol)
	- IPv4 has 32 bits, IPv6 has 128.
	- The network layer has path selection algorithms, which lead into a forwarding table. The next major part of this is the Internet Protocol (IP). This includes:
		- Datagram format
		- Addressing
		- Packet handling conventions
	- The other major part is the Internet Control Messaging Protocol (ICMP), which is responsible for:
		- Error reporting
		- Router "signaling"
	- There's a gigantic IP datagram format, we don't need to remember it.
	- Base 2 numbers! I can't stand subnet masks. 
	- IP Addressing:
		- So we have a different subnet on each "end" of a router.
		- Devices in the same subnet have similar IPs, as our IP range is determined by our subnet.
		- IP addresses are 32-bit identifiers associated with each host or router interface
		- Interfaces are connections between hosts and routers and physical link:
			- Routers typically have multiple interfaces
			- Hosts typically have one or two (ethernet, wireless, sometimes a VPN)
		- 233.1.1.1 is equivalent to 11101001.00000001.00000001.00000001, always remember that everything is binary. 
	- Classful addressing:
		- She isn't going through the slides, she really needs them to make any sense at all. What I'm getting is that this is our way of using IPv4 despite not having enough addresses for all devices.
		- So our first $n$ bits are the netid, the last $32-n$ bits are the hostid (reading left to right).
			- The first address is \[NETID\]0000, the final address is \[NETID\]1111
		- We have classes A through E to worry about. This data is PROBABLY accurate for the class, refer to slides:
			- Class A: first byte is 0-127, \[8 bit netid\]\[24 bit hostid\], subnet mask 255.0.0.0 ($2^{24}$ hosts)
			- Class B: first byte is 128-191, \[16 bit netid\]\[16 bit hostid\], subnet mask 255.255.0.0 ($2^16$ hosts)
			- Class C: first byte is 192-223, \[24 bit netid\]\[8 bit hostid\], subnet mask 255.255.255.0 ($2^8$ hosts)
			- Class D: first byte is 224-239, not normal
			- Class E: first byte is 240-255, not normal
		- We mainly deal with A, B, and C. 
		- Netid is always \[netid\] followed by all zeroes.
		- Hostid is the netid numbers replaced with zeroes and then the hostid numbers.
		- Maskid is the subnet mask. 
		- Exercise: an address in a block is given as 180.8.17.9. Which class do we have, find the netid, hostid, and number of addresses in the block.
			- Class: B
			- Netid: 180.8.0.0
			- Hostid: 0.0.17.9
			- Number of addresses: $2^{32-16}=2^{16}$
		- Trick for finding subnet masks: take the netid bits and set everything to 1, take the hostid bits and set everything to 0.
	- Classless:
		- We can choose any length for the netid.
		- We need to follow CIDR (Classless Inter-Domain Routing)
		- If we are classless, we need a subnet mask to know all of this information. 
		- You could have a subnet mask like 255.255.240.0, which means we have 12 hostid bits. If we have a netid/IP example and a subnet mask we can easily determine everything. 
		- So that whole wack notation of like /16 just means the prefix length is that many bytes. This makes a lot of sense!
		- Network mask: replace all bits in the prefix with "1" and all bits in the suffix with "0"
		- Netid: Keep with original number in the prefix then replace all suffix bits with 0
		- Hostid: Keep with original number in the suffix then replace all prefix bits with 0
		- Example:
			- 230.7.24.46/20
			- We have a prefix length of 20
			- Binary: ***11100110.00001000.0001***1000.00101101 (***prefix***)
			- So we have a hostid of 230.7.16.0
			- We have a netid of 0.0.8.46
	- We can further divide our networks with subnets.
		- For example, take 18.14.12.0/24
		- We can divide this into four smaller blocks if we vary the last two bits in our netid area. That would yield four subnets:
			- 18.14.12.0/24
			- 18.14.13.0/24
			- 18.14.14.0/24
			- 18.14.15.0/24
		- Go to the slides again to understand subnetting a little better
	- How do we get IPs?
		- Two questions inside this:
			1. ...
			2. ...
		- She cut us off again.
		- The answer is Dynamic Host Configuration Protocol (DHCP). We want to dynamically assign/obtain IPs when a host joins a network.
		- Should be able to:
			- Renew its lease on address in use
			- Allows reuse of addresses
			- Support for mobile users who join/leave network
		- DHCP server is in charge of this. Arriving client sends out a DHCP discover request, the server hears them and will attempt to assign them an IP.
		- Go back in on IP address stuff, especially for allocation